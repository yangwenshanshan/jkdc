import type { Axios, AxiosInterceptorManager, AxiosInterceptorOptions, AxiosRequestConfig, AxiosResponse, InternalAxiosRequestConfig } from 'axios'
import axios from 'axios'
import { useCancelSourceStore } from '@/stores/cancelSourceStore'

interface YbAxiosResponse<D = any> extends AxiosResponse<YbAxiosData, D> {}
interface YbAxiosInterceptorManager {
  use(onFulfilled?: ((value: YbAxiosResponse) => any | Promise<YbAxiosData>) | null, onRejected?: ((error: any) => any) | null, options?: AxiosInterceptorOptions): number
  eject(id: number): void
  clear(): void
}
interface YbAxiosInstance extends Axios {
  interceptors: {
    request: AxiosInterceptorManager<InternalAxiosRequestConfig>
    response: YbAxiosInterceptorManager
  }
  getUri(config?: AxiosRequestConfig): string
  request<R = YbAxiosData, D = any>(config: AxiosRequestConfig<D>): Promise<R>
  get<R = YbAxiosData, D = any>(url: string, config?: AxiosRequestConfig<D>): Promise<R>
  delete<R = YbAxiosData, D = any>(url: string, config?: AxiosRequestConfig<D>): Promise<R>
  head<R = YbAxiosData, D = any>(url: string, config?: AxiosRequestConfig<D>): Promise<R>
  options<R = YbAxiosData, D = any>(url: string, config?: AxiosRequestConfig<D>): Promise<R>
  post<R = YbAxiosData, D = any>(url: string, data?: D, config?: AxiosRequestConfig<D>): Promise<R>
  put<R = YbAxiosData, D = any>(url: string, data?: D, config?: AxiosRequestConfig<D>): Promise<R>
  patch<R = YbAxiosData, D = any>(url: string, data?: D, config?: AxiosRequestConfig<D>): Promise<R>
  postForm<R = YbAxiosData, D = any>(url: string, data?: D, config?: AxiosRequestConfig<D>): Promise<R>
  putForm<R = YbAxiosData, D = any>(url: string, data?: D, config?: AxiosRequestConfig<D>): Promise<R>
  patchForm<R = YbAxiosData, D = any>(url: string, data?: D, config?: AxiosRequestConfig<D>): Promise<R>
  <R = YbAxiosData, D = any>(config: AxiosRequestConfig<D>): Promise<R>
  <R = YbAxiosData, D = any>(url: string, config?: AxiosRequestConfig<D>): Promise<R>
}
interface YbAxiosData {
  data: any
  ldata: Array<any>
  mdata: any
  message: string
  objData: any
  result: number
}

const http: YbAxiosInstance = axios.create({
  baseURL: '',
})

http.interceptors.request.use(
  (config) => {
    const cancelSource = useCancelSourceStore()

    if (config.method === 'get') {
      config.params = {
        ...config.params,
        _t: Date.parse(`${new Date()}`),
      }

      // 根据接口url,method,_t确定唯一接口
      const cancelKey = `${config.url}_${config.method}_${config.params._t}`

      if (!config.cancelToken) {
        const source = axios.CancelToken.source()
        config.cancelToken = source.token
        cancelSource.add(cancelKey, source)
      }
    }

    return config
  },
  (error) => {
    return Promise.reject(error)
  },
)

http.interceptors.response.use(
  (response) => {
    const config = response.config

    if (config.method === 'get') {
      const cancelSource = useCancelSourceStore()
      const cancelKey = `${config.url}_${config.method}_${config.params._t}`
      cancelSource.remove(cancelKey)
    }

    return response.data
  },
  (error) => {
    if (!axios.isCancel(error)) {
      ElMessage({
        type: 'error',
        message: error.message,
      })

      return Promise.reject(error)
    }
  },
)

export default http





/**
 * axios封装添加cancel配合http.ts
 */
import { defineStore } from 'pinia'
import type { CancelTokenSource } from 'axios'

interface SourceObject {
  [key: string]: CancelTokenSource
}

export const useCancelSourceStore = defineStore('cancelSource', {
  state: () => ({
    cancelSource: {} as SourceObject,
  }),
  actions: {
    get(name: string) {
      return this.cancelSource[name]
    },
    add(name: string, source: CancelTokenSource) {
      this.cancelSource[name] = source
    },
    remove(name: string) {
      delete this.cancelSource[name]
    },
    run() {
      Object.keys(this.cancelSource).forEach((key: string) => {
        this.cancelSource[key].cancel()
        this.remove(key)
      })
    },
  },
})
